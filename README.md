Cahier des charges â€“ Automatisation Instagram / TikTok (C# / WinForms)
1. Objectif
DÃ©velopper un outil Windows en C# (.NET 6/8, WinForms) permettant :
De gÃ©rer plusieurs profils (Instagram et TikTok).


De lancer un navigateur configurÃ© avec des empreintes anti-dÃ©tection (fingerprints + proxy).


Dâ€™exÃ©cuter des scripts dâ€™automatisation rÃ©alistes (Target, Scroll, Publish).


Dâ€™assurer la gestion multi-profils, la planification dâ€™actions et le suivi statistique.


De conserver une interface simple et des logs clairs.



2. FonctionnalitÃ©s principales
2.1 Gestion des profils (MainForm)
Inputs :


Plateforme : Instagram ou TikTok.


Nom de profil (identifiant unique).


Proxy associÃ© (http://ip:port ou socks5://ip:port).


Actions :


CrÃ©er un profil â†’ gÃ©nÃ¨re fingerprints + sauvegarde (JSON ou SQLite).


Supprimer un profil existant.


SÃ©lectionner un profil dans la liste (ListBox ou DataGridView).


Lancer le navigateur avec les paramÃ¨tres du profil.


Persistance :


Profils stockÃ©s dans profiles.json ou SQLite.


Cookies/session isolÃ©s par profil.


Multi-profils simultanÃ©s :


Support du threading / async pour gÃ©rer plusieurs profils en parallÃ¨le.



2.2 Anti-dÃ©tection / Fingerprinting
Chaque profil doit simuler un utilisateur rÃ©el via :
User-Agent dynamique (desktop/mobile).


Fuseau horaire, langue, rÃ©solution Ã©cran, WebGL, Canvas, plugins.


Spoofing hardware (CPU/GPU, fonts, concurrency).


Masquage automatisation (navigator.webdriver, WebRTC, etc.).


Proxy dÃ©diÃ© (rÃ©sidentiel/mobile de prÃ©fÃ©rence).


Sessions/cookies persistants restaurÃ©s automatiquement.


ğŸ‘‰ ImplÃ©mentation avec PuppeteerSharp ou PlaywrightSharp en C# et scripts JS injectÃ©s.

2.3 Actions (Forms spÃ©cifiques)
Chaque plateforme dispose de son Form (InstagramBotForm / TikTokBotForm) avec trois boutons : Target, Scroll, Publish.
a) Target
Charge targets.txt (UTF-8, un profil par ligne).


Pour chaque profil :


Ouvre le dernier Reel/post â†’ like + commentaire (alÃ©atoire).


Visionne 5â€“10 Reels suivants (5â€“10 sec chacun) â†’ like environ 20%.


Gestion dâ€™erreurs : profil privÃ©, inexistant ou sans contenu â†’ log + skip.


Fermeture du navigateur en fin de traitement.


b) Scroll
AccÃ¨de Ã  la page des Reels (/reels/ ou /foryou).


Pendant 20â€“40 min :


Visionnage alÃ©atoire avec scroll fluide et pauses variables.


Like ~30%, commentaire ~30% (contenu alÃ©atoire).


Fermeture automatique Ã  la fin.


c) Publish
Lit schedule.csv ou Excel (Date / Account / Plateforme / Media Path / Description).


Filtre par date du jour + compte sÃ©lectionnÃ© + plateforme.


Pour chaque ligne correspondante :


Ouvre la page de publication.


Upload du mÃ©dia (photo/vidÃ©o) et ajout de la description.


VÃ©rification erreurs (fichier manquant, format non supportÃ©).


Fermeture automatique aprÃ¨s les publications.



3. Gestion des fichiers
targets.txt : liste des cibles (UTF-8).


schedule.csv : planification des publications.


profiles.json : stockage des profils et fingerprints.


Logs/ : fichiers .log avec rotation quotidienne et export JSON.



4. Interface utilisateur
MainForm.cs : CRUD profils + lancement navigateur.


InstagramBotForm.cs / TikTokBotForm.cs : boutons Target / Scroll / Publish.


Tableau de bord temps rÃ©el : progression, logs, statut navigateur.


Dashboard statistique : graphiques sur engagement (likes, commentaires, publications rÃ©ussies).


Scheduler intÃ©grÃ© : possibilitÃ© de planifier lâ€™exÃ©cution automatique des scripts.



5. Logs & suivi
Logger centralisÃ© (Logger.cs).


Niveaux : INFO / WARNING / ERROR.


Exemple :
 [2025-10-02 12:35:20][INFO] Profil "insta_demo" â†’ Like effectuÃ© sur Reel #id123


Logs affichÃ©s en temps rÃ©el dans lâ€™interface + sauvegarde persistante.


Analyse post-exÃ©cution (nb likes, nb commentaires, nb publications).



6. ParamÃ©trage
Fichier config.json pour ajuster :


DurÃ©e visionnage min/max (ex: 5â€“10s).


% like/comment (avec plage alÃ©atoire).


Nombre max de Reels par profil.


DÃ©lais entre actions.


ParamÃ¨tres modifiables directement depuis lâ€™interface.



7. Stack technique
Langage : C# .NET 6 ou .NET 8


UI : WinForms


Automation : PuppeteerSharp ou PlaywrightSharp


Parsing CSV/Excel : CsvHelper + ClosedXML


Persistance : JSON (Newtonsoft.Json) ou SQLite


Logging : Serilog ou Logger custom



8. SÃ©curitÃ© & limitations
Automatisation = violation CGU Instagram/TikTok â†’ risque de bannissement.


Actions doivent intÃ©grer de lâ€™alÃ©atoire (temps, taux dâ€™interaction, dÃ©placements souris).


Proxy obligatoire (HTTP/SOCKS5).


Nettoyage mÃ©moire + fermeture navigateur aprÃ¨s chaque run.


Limites de sÃ©curitÃ© intÃ©grÃ©es (ex: max 50 likes/jour/profil).



9. Structure projet
SocialNetworkArmy/
â”‚
â”œâ”€â”€ Data/
â”‚   â”œâ”€â”€ profiles.json
â”‚   â”œâ”€â”€ targets.txt
â”‚   â”œâ”€â”€ schedule.csv
â”‚   â””â”€â”€ Logs/
â”‚
â”œâ”€â”€ Scripts/
â”‚   â”œâ”€â”€ instagram/ (target.js, scroll.js, publish.js)
â”‚   â””â”€â”€ tiktok/ (target.js, scroll.js, publish.js)
â”‚
â”œâ”€â”€ Services/
â”‚   â”œâ”€â”€ ProfileService.cs
â”‚   â”œâ”€â”€ AutomationService.cs
â”‚   â”œâ”€â”€ ProxyService.cs
â”‚   â””â”€â”€ FingerprintService.cs
â”‚
â”œâ”€â”€ Forms/
â”‚   â”œâ”€â”€ MainForm.cs
â”‚   â”œâ”€â”€ InstagramBotForm.cs
â”‚   â””â”€â”€ TikTokBotForm.cs
â”‚
â”œâ”€â”€ Models/
â”‚   â”œâ”€â”€ Profile.cs
â”‚   â”œâ”€â”€ Fingerprint.cs
â”‚   â””â”€â”€ ScheduleEntry.cs
â”‚
â””â”€â”€ Utils/
â”œâ”€â”€ Logger.cs
â”œâ”€â”€ Config.cs
â””â”€â”€ Helpers.cs















LES COMPTES DOIVENT SURVIVRE :
 
Anti-dÃ©tection / Fingerprinting 


Pour assurer que Instagram et TikTok ne dÃ©tectent jamais l'automatisation, il faut implÃ©menter une stratÃ©gie complÃ¨te d'Ã©vasion couvrant les empreintes digitales (fingerprints), les comportements humains simulÃ©s, les protocoles de communication, et les limites d'activitÃ©. L'objectif est de rendre l'outil indistinguable d'un utilisateur rÃ©el en Ã©vitant tous les signaux de dÃ©tection connus (comme les flags d'automatisation, les patterns comportementaux anormaux, ou les artefacts techniques). Voici une liste exhaustive de tous les Ã©lÃ©ments Ã  considÃ©rer et implÃ©menter, basÃ©e sur les meilleures pratiques pour PuppeteerSharp ou PlaywrightSharp. Cela inclut des techniques basiques (dÃ©jÃ  mentionnÃ©es) et avancÃ©es pour contourner les dÃ©fenses modernes comme les VMs obfuscÃ©es de TikTok ou les fingerprintings basÃ©s sur l'IA d'Instagram.
Empreintes digitales (Fingerprints) Ã  spoofer

User-Agent dynamique: GÃ©nÃ©rer alÃ©atoirement des User-Agents rÃ©alistes (basÃ©s sur des listes de navigateurs rÃ©els comme Chrome, Firefox sur desktop/mobile). Ã‰viter les User-Agents par dÃ©faut de Puppeteer/Playwright qui incluent "HeadlessChrome". Rotation par session ou par action pour matcher des dispositifs variÃ©s (ex: iOS pour TikTok mobile-like).
Fuseau horaire et langue: Spoofer le timezone (ex: via Intl.DateTimeFormat) et la langue du navigateur (navigator.languages) pour correspondre Ã  des utilisateurs rÃ©els (ex: alÃ©atoire par proxy gÃ©olocalisÃ©). Utiliser des valeurs cohÃ©rentes avec le proxy (ex: US pour un proxy amÃ©ricain).
RÃ©solution d'Ã©cran et viewport: Randomiser la rÃ©solution (ex: 1920x1080, 1280x720) et le viewport pour simuler diffÃ©rents appareils. Ã‰viter les rÃ©solutions par dÃ©faut headless qui sont dÃ©tectables.
WebGL et Canvas fingerprinting: Spoofer les rendus WebGL (vendor/renderer) et Canvas (via injection JS pour modifier toDataURL ou ajouter du bruit alÃ©atoire aux pixels). TikTok utilise spÃ©cifiquement cela dans sa VM obfuscÃ©e ; ajouter du bruit unique par session pour Ã©viter les matches exacts.
Audio fingerprinting: Modifier les propriÃ©tÃ©s audio (ex: AudioContext, oscillatorNode) pour ajouter du bruit alÃ©atoire et Ã©viter les fingerprints statiques.
Fonts et plugins: Spoofer la liste des fonts installÃ©es (via injection pour simuler des sets communs comme Arial, Times New Roman). Ajouter des plugins manquants (ex: PDF viewer, Flash-like stubs) pour matcher un navigateur rÃ©el ; Puppeteer headless manque souvent ces Ã©lÃ©ments.
Hardware spoofing: Randomiser le hardware concurrency (navigator.hardwareConcurrency, ex: 4-16 cÅ“urs), CPU/GPU info (via WebGL), et mÃ©moire disponible. Utiliser des valeurs plausibles basÃ©es sur des stats rÃ©elles d'utilisateurs.
WebRTC masking: DÃ©sactiver ou spoofer WebRTC (ex: navigator.mediaDevices) pour cacher l'IP rÃ©elle ; configurer pour matcher le proxy et Ã©viter les leaks.
Autres APIs navigateur: Spoofer navigator.platform, navigator.vendor, screen.depth, navigator.maxTouchPoints (pour simuler touch sur mobile). Utiliser des proxies JS pour intercepter et modifier ces appels.

Masquage des indicateurs d'automatisation

DÃ©sactiver navigator.webdriver: DÃ©finir navigator.webdriver Ã  undefined via page.addInitScript (Playwright) ou page.evaluateOnNewDocument (Puppeteer). C'est un flag clÃ© dÃ©tectÃ© par Instagram et TikTok.
Cacher les artefacts CDP (Chrome DevTools Protocol): Minimiser l'usage de CDP pour Ã©viter les dÃ©tections protocol-level (ex: WebSocket communications, object serialization). Utiliser des frameworks avancÃ©s comme Nodriver ou Selenium Driverless pour rÃ©implÃ©menter les primitives d'automatisation sans CDP/WebDriver.
Mode headful vs headless: PrÃ©fÃ©rer le mode headful (visible) pour certaines actions, car headless laisse des traces (ex: codebase unifiÃ© de Chrome depuis 2022 rend headless plus dÃ©tectable). Basculer dynamiquement en fonction du risque.
Ã‰viter les VMs obfuscÃ©es (spÃ©cifique TikTok): Pour TikTok, qui compile son JS en bytecode exÃ©cutÃ© par une VM custom, extraire/reimplÃ©menter l'interprÃ©teur ou Ã©muler le bytecode manuellement. Utiliser un navigateur complet pour gÃ©nÃ©rer des signaux valides au lieu de bots HTTP purs.
IntÃ©gration avec anti-detect browsers: Utiliser des patches comme Rebrowser pour Puppeteer/Playwright, ou intÃ©grer avec des browsers anti-detect commerciaux (ex: pour spoofing avancÃ© et rotation automatique).

Gestion des proxies et rÃ©seau

Proxies dÃ©diÃ©s et rotation: Utiliser exclusivement des proxies rÃ©sidentiels ou mobiles (pas datacenter, car dÃ©tectables). Rotation automatique d'IP par session ou aprÃ¨s N actions (ex: toutes les 10-20 min). Support HTTP/SOCKS5 avec authentification. GÃ©olocaliser les proxies pour matcher le fingerprint (ex: proxy US pour un User-Agent amÃ©ricain).
Rotation des headers HTTP: Randomiser les headers comme Referer, Accept-Language, Accept-Encoding, et Connection. Ã‰viter les patterns statiques ; utiliser des listes rÃ©alistes.
Gestion des CAPTCHAs: Ã‰viter de les dÃ©clencher en imitant les humains ; si dÃ©clenchÃ©s, intÃ©grer un solver externe (ex: via API). Surveiller les patterns qui les activent (ex: trop de requÃªtes rapides).

Simulation de comportements humains

DÃ©placements de souris et clics: Simuler des mouvements courbes avec accÃ©lÃ©ration/dÃ©cÃ©lÃ©ration (pas linÃ©aires). Utiliser des libs comme puppeteer-mouse pour des paths alÃ©atoires. Pour les likes/comments, ajouter des hovers alÃ©atoires avant clic.
Vitesse de frappe et saisie: Typer les commentaires avec des dÃ©lais variables par caractÃ¨re (ex: 100-300ms), inclure des erreurs/backspaces alÃ©atoires pour humaniser.
Scroll fluide et pauses: ImplÃ©menter un scroll non-linÃ©aire avec vitesse variable (ex: accÃ©lÃ©rer puis ralentir). Ajouter des pauses alÃ©atoires (ex: 2-10s) pendant le visionnage de Reels.
Taux d'interaction alÃ©atoires: Like ~20-30% avec variance (ex: Poisson distribution), commentaires ~10-30% avec contenu gÃ©nÃ©rÃ© alÃ©atoirement (ex: emojis variÃ©s, phrases courtes). Configurable via config.json avec plages min/max.
DurÃ©es de session variables: Sessions de 20-40 min avec fin alÃ©atoire ; Ã©viter les durÃ©es fixes. Inclure des "pauses inactives" simulÃ©es.
Ordre des actions randomisÃ©: Ne pas suivre un ordre fixe (ex: like puis comment) ; randomiser la sÃ©quence pour Ã©viter les patterns.
Gestion des erreurs humaine: Sur profil privÃ©/inexistant, simuler un "regard" bref puis back ; loguer sans paniquer.

Limites de sÃ©curitÃ© et anti-patterns

Limites quotidiennes: IntÃ©grer des caps hardcodÃ©s (ex: max 50 likes/jour/profil, 20 follows, 10 posts) pour Ã©viter les flags d'activitÃ© anormale. Configurable mais avec warnings si dÃ©passÃ©.
Randomisation globale: Utiliser des distributions statistiques (ex: normale pour dÃ©lais) pour tous les timings/interactions. Ã‰viter les boucles prÃ©dictibles.
Nettoyage post-session: Fermer le navigateur, effacer la mÃ©moire/cache temporaire, tuer les processus rÃ©siduels pour Ã©viter les leaks.
Multi-threading prudent: Pour multi-profils, utiliser async avec dÃ©lais entre lancements pour Ã©viter les bursts d'activitÃ© dÃ©tectables.
Ã‰viter les signaux d'automatisation avancÃ©e: Pas de navigation trop rapide, pas d'accÃ¨s direct Ã  des URLs internes sans simulation de navigation.

ImplÃ©mentation technique

Libs et plugins: Utiliser puppeteer-extra-plugin-stealth ou playwright-extra pour des patches automatiques. Injecter des scripts JS custom pour spoofing (ex: via page.evaluate).
Monitoring et adaptation: Logger les dÃ©tections potentielles (ex: CAPTCHAs, bans) et ajuster dynamiquement (ex: ralentir si warning). Mettre Ã  jour les fingerprints pÃ©riodiquement via config.
Test et validation: Tester contre des outils comme CreepJS ou FingerprintJS pour vÃ©rifier l'unicitÃ© des fingerprints. Simuler des runs sur des comptes tests pour mesurer les taux de ban.
Ã‰volution des dÃ©fenses: Surveiller les updates (ex: unification Chrome headless/headful, VMs TikTok) et patcher en consÃ©quence. PrÃ©voir une modularitÃ© pour switcher vers des frameworks comme Nodriver si Puppeteer devient trop dÃ©tectable.

PACKAGES NUGGETS

Microsoft.Web.WebView2 Pour l'automatisation navigateur + anti-dÃ©tection
CsvHelper --version 30.0.1  # Parsing CSV pour schedule.csv
ClosedXML --version 0.102.1  # Parsing Excel si tu ajoutes du support
Newtonsoft.Json --version 13.0.3  # JSON pour profiles.json et fingerprints
Serilog --version 3.1.1  # Logging avancÃ© (remplace Logger custom)
Serilog.Sinks.File --version 6.0.0  # Pour rotation logs quotidiens
Serilog.Sinks.Console --version 5.0.1  # Logs en console pour debug




